\documentclass[a4paper]{article}
\usepackage[pdftex]{geometry}
\usepackage[utf8]{inputenc}

\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{courier}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{lastpage}

\lstset{columns=fullflexible}
\lstset{basicstyle=\scriptsize\ttfamily}
\lstset{showspaces=false}
\lstset{showstringspaces=false}
%
\geometry{portrait}
\setlength{\topmargin}{-0.5in}
\setlength{\oddsidemargin}{-0.5in}
%\setlength{\evensidemargin}{-in}
\setlength{\columnsep}{1in}
\setlength{\columnseprule}{0.2pt}
\textwidth 185mm
\textheight 250mm

\pagestyle{fancy}
\lhead{Nizhny Novgorod Branch of NRU HSE (Doroshenko, Orlova, Zarkov)}
\chead{}
\rhead{\thepage\ of \pageref{LastPage}}
\lfoot{}
\cfoot{}
\rfoot{}

\usepackage{cmap}					% поиск в PDF
\usepackage{mathtext} 				% русские буквы в формулах
\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы

%%% Дополнительная работа с математикой
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} % AMS
\usepackage{icomma} % "Умная" запятая: $0,2$ --- число, $0, 2$ --- перечисление

%% Номера формул
\mathtoolsset{showonlyrefs=true} % Показывать номера только у тех формул, на которые есть \eqref{} в тексте.

%% Шрифты
\usepackage{euscript}	 % Шрифт Евклид
\usepackage{mathrsfs} % Красивый матшрифт

\newcommand{\includecpp}[2]{
	\subsection{#1}\
	\lstinputlisting[language=c++, breaklines=true]{#2}
}

\newcommand{\floor}[1]{\lfloor #1 \rfloor}

\begin{document}
	\thispagestyle{fancy}
	\pagenumbering{Roman}
	
	\begin{center}
		\Huge\textsc{ICPC Team Reference Document}
		
		\huge HSE-NN 2
		
		\vspace{0.50cm}
	\end{center}
	
	\begin{multicols*}{2}
		\tableofcontents
		
		\pagenumbering{arabic}
		\setcounter{page}{1}
		%\input{contents.tex}
	\end{multicols*}
	\enlargethispage*{\baselineskip}
	\pagebreak
	
	% == CONTENTS == %
	
	\pagenumbering{arabic}
	\setcounter{page}{2}
	%
	\begin{multicols*}{2}
		\section{Шаблон}
		\lstinputlisting[language=C++]{fcpp/template.cpp}
		
		\section{Алгоритмы на строки}
		\subsection{Префикс-функция}
		\lstinputlisting[language=C++]{fcpp/pfunc.cpp}
		\subsection{Z-функция}
		\lstinputlisting[language=C++]{fcpp/zfunc.cpp}
		\subsection{Хеширование}
		\lstinputlisting[language=C++]{fcpp/hash.cpp}
		
		\section{Алгоритмы на графах}
		\subsection{Алгоритм Дейкстры $O(n^2)$}
		was - брали вершину или нет 
		v - список смежности 
		d - массив расстояний для точки x
		\lstinputlisting[language=C++]{fcpp/dijkstra-n2.cpp}
		\subsection{Алгоритм Дейкстры $O(log(n) \cdot m)$}
		d - массив расстояний для точки x
		\lstinputlisting[language=C++]{fcpp/dijkstra-nm.cpp}		
		\subsection{Поток}
		\lstinputlisting[language=C++]{fcpp/potol.cpp}
		\subsection{Поиск компонент сильной связности, построение конденсации графа $O(N+M)$}
		Дан ориентированный граф G, множество вершин которого V и множество рёбер — E. Петли и кратные рёбра допускаются. Обозначим через n количество вершин графа, через m — количество рёбер.
		
		Компонентой сильной связности (strongly connected component) называется такое (максимальное по включению) подмножество вершин C, что любые две вершины этого подмножества достижимы друг из друга, т.е. для $\forall u,v \in C:$
		
		$u \mapsto v, v \mapsto u $
		\lstinputlisting[language=C++]{fcpp/strong_connected_components.cpp}
		\subsection{Поиск мостов $O(N+M)$}
		Пусть дан неориентированный граф. Мостом называется такое ребро, удаление которого делает граф несвязным (или, точнее, увеличивает число компонент связности). Требуется найти все мосты в заданном графе.		
		\lstinputlisting[language=C++]{fcpp/bridge_searching.cpp}
		\subsection{Поиск точек сочленения}
		Пусть дан связный неориентированный граф. Точкой сочленения (или точкой артикуляции, англ. "cut vertex" или "articulation point") называется такая вершина, удаление которой делает граф несвязным.
		\lstinputlisting[language=C++]{fcpp/cutpoints.cpp}
		
		\section{Простые алгоритмы}		
		\subsection{Решето Эратосфена $O(n)$}
		pr - все простые числа до n \\
		lp - минимальный простой делитель числа i
		\lstinputlisting[language=C++]{fcpp/resheto-n.cpp} 
		

		\subsection{Решето Эратосфена \\ $O(n \cdot log(log(n)))$}
		d[i] == 0 если число i простое
		\lstinputlisting[language=C++]{fcpp/resheto-nloglogn.cpp}
		\subsection{Умножение чисел по модулю}
		\lstinputlisting[language=C++]{fcpp/mulmod.cpp}
		\subsection{Функция Эйлера}
		Количество таких чисел в отрезке [1; n], наибольший общий делитель которых с n равен единице.
		
		Если p — простое число, то $\phi$ (p)=p-1.
		(Это очевидно, т.к. любое число, кроме самого p, взаимно просто с ним.)
		
		Если p — простое, a — натуральное число, то $\phi (p^a)=p^a-p^{a-1}$.
		(Поскольку с числом $p^a$ не взаимно просты только числа вида $pk (k \in \mathcal{N})$, которых $p^a / p = p^{a-1}$ штук.)
		
		Если a и b взаимно простые, то $\phi(ab) = \phi(a) \phi(b) $
		
		Самое известное и важное свойство функции Эйлера выражается в теореме Эйлера:
		
		$a^{\phi(m)} \equiv 1 \pmod m$, 
		
		где $\it a$ и $\it m$ взаимно просты.
		В частном случае, когда $\it m$ простое, теорема Эйлера превращается в так называемую малую теорему Ферма:
		
		$a^{m-1} \equiv 1  \pmod m $
		\lstinputlisting[language=C++]{fcpp/euler_function.cpp}
		\subsection{Алгоритм Евклида}
		\lstinputlisting[language=C++]{fcpp/euclid_algorithm.cpp}
		\subsection{Расширенный алгоритм Евклида}
		$a \cdot x + b \cdot y = {\rm gcd} (a, b).$
		\lstinputlisting[language=C++]{fcpp/extended_euclid_algorithm.cpp}
		\subsection{Обратный элемент в кольце по модулю}
		Обратным к числу a по модулю m называется такое число b, что:
		
		$a \cdot b \equiv 1 \pmod m$
		\lstinputlisting[language=C++]{fcpp/reverse_element1.cpp}
		\subsection{Нахождение всех простых по заданному модулю за линейное время}
		\lstinputlisting[language=C++]{fcpp/reverse_element2.cpp}
		\subsection{Дискретное логарифмирование}
		Задача дискретного логарифмирования заключается в том, чтобы по данным целым a, b, m решить уравнение:
		
		$a^x = b \pmod m$, 
		
		где a и m — взаимно просты 
		\lstinputlisting[language=C++]{fcpp/discrete_log.cpp}
		\subsection{Китайская теорема об остатках}
		\lstinputlisting[language=C++]{fcpp/chinese_theorem.cpp}
		
		\section{Структуры данных}
		\subsection{Дерево отрезков}
		\lstinputlisting[language=C++]{fcpp/subtree.cpp}
		 Прибавление на отрезке
		 \lstinputlisting[language=C++]{fcpp/subtree-add.cpp}
		 Присвоение на отрезке
		 \lstinputlisting[language=C++]{fcpp/subtree-push.cpp}
		 \subsection{Дерево Фенвика для суммы для одномерного случая}
		 \lstinputlisting[language=C++]{fcpp/fenwick_tree1.cpp}		 
		 \subsection{Дерево Фенвика для суммы для одномерного случая}
		 \lstinputlisting[language=C++]{fcpp/fenwick_tree2.cpp}
		 
		 \section{Геометрия}
		 \subsection{Полярный угол}
		 \lstinputlisting[language=C++]{fcpp/polyar.cpp}
		 \subsection{Скалярное произведение, угол между векторами}
		 
		 $\vec a \cdot \vec b = |\vec a| \cdot |\vec b| \cdot cos \varphi$
		 
		 $\vec a \cdot \vec b = x_1 \cdot x_2 + y_1 \cdot y_2$
		 
		 $|\vec a| = \sqrt{x^2 + y^2}$
		 \lstinputlisting[language=C++]{fcpp/skalar.cpp}
		 \subsection{Площадь многоугольника}
		 \lstinputlisting[language=C++]{fcpp/ploshad.cpp}		 
		 \subsection{Площадь треугольника}
		 \lstinputlisting[language=C++]{fcpp/ploshad-tr.cpp}
		 \subsection{Расстояние от точки до прямой}
		 a b c коэффициенты нормального уравнения прямой
		 \lstinputlisting[language=C++]{fcpp/rast-t-p.cpp}
		 \subsection{Нормальное уравнение по двум точкам}
		 \lstinputlisting[language=C++]{fcpp/norm-yr.cpp}	
		 
		 \section{Числа Фибоначчи}		 
		 \subsection{Свойства чисел Фибоначчи}
		 
		 Соотношение Кассини:
		 
		 $F_{n+1} F_{n-1} - F_n^2 = (-1)^n.$
		 
		 Правило "сложения":
		 
		 $F_{n+k} = F_k F_{n+1} + F_{k-1} F_n.$ 
		 
		 Из предыдущего равенства при k = n вытекает:
		 
		 $F_{2n} = F_n (F_{n+1} + F_{n-1}).$ 
		 
		 Из предыдущего равенста по индукции можно получить, что
		 
		 $F_{nk}$ всегда кратно $F_n$.
		 
		 Верно и обратное к предыдущему утверждение:
		 
		 если $F_m$ кратно $F_n$, то m кратно n.
		 
		 НОД-равенство:
		 
		 ${\rm gcd} (F_m, F_n) = F_{{\rm gcd} (m, n)}$. 
		 
		 Теорема Цекендорфа утверждает, что любое натуральное число n можно представить единственным образом в виде суммы чисел Фибоначчи:
		 
		 $N = F_{k_1} + F_{k_2} + \ldots + F_{k_r}$
		 
		 где $k_1 \ge k_2+2, k_2 \ge k_3+2, \ldots, k_r \ge 2$ (т.е. в записи нельзя использовать два соседних числа Фибоначчи).
		 
		 Нетрудно получить и правило прибавления единицы к числу в фибоначчиевой системе счисления: если младшая цифра равна 0, то её заменяем на 1, а если равна 1 (т.е. в конце стоит 01), то 01 заменяем на 10. Затем "исправляем" запись, последовательно исправляя везде 011 на 100. В результате за линейное время будет получена запись нового числа.
		 
		 Перевод числа в фибоначчиеву систему счисления осуществляется простым "жадным" алгоритмом: просто перебираем числа Фибоначчи от больших к меньшим и, если некоторое $F_k \le n$, то $F_k$ входит в запись числа n, и мы отнимаем $F_k$ от n и продолжаем поиск.
		 
		 
	\end{multicols*}
\end{document}